---
output: 
    html_document:
        theme: sandstone
        toc: true
        toc_float: true
        df_print: kable
        code_folding: show
    pdf_document:
        toc: true
always_allow_html: yes
editor_options: 
    chunk_output_type: console
title: "`r paste0('Alevin report, ', sampleId)`"
---

```{r prep, include = FALSE}
knitr::opts_chunk$set(echo = showCode, warning = FALSE, message = FALSE)
knitr::opts_knit$set(progress = FALSE, verbose = FALSE)
```

```{r setup}
## -------------------------------------------------------------------------- ##
## Load packages
## -------------------------------------------------------------------------- ##
if (!quiet) message("Loading packages...")
suppressPackageStartupMessages({
    library(ggplot2)
    library(GGally)
    library(dplyr)
    library(rjson)
})

alevinDir <- file.path(baseDir, "alevin")

## -------------------------------------------------------------------------- ##
## Read files
## -------------------------------------------------------------------------- ##
if (!quiet) message("Reading Alevin output files...")
## Raw CB frequencies
rawcbfreq <- utils::read.delim(file.path(alevinDir, "raw_cb_frequency.txt"), 
                               header = FALSE, as.is = TRUE) %>%
    dplyr::rename(CB = V1, originalFreq = V2) %>%
    dplyr::mutate(ranking = seq_len(length(CB)))

## First set of whitelisted CBs (quantified)
filtcbfreq <- read.delim(file.path(alevinDir, "filtered_cb_frequency.txt"),
                         header = FALSE, as.is = TRUE) %>%
    dplyr::rename(CB = V1, collapsedFreq = V2) %>%
    dplyr::left_join(rawcbfreq, by = "CB")

## FeatureDump
featuredump <- read.delim(file.path(alevinDir, "featureDump.txt"),
                          header = FALSE, as.is = TRUE) %>%
    dplyr::rename(CB = V1, mappingRate = V2, duplicationRate = V3,
                  unknown1 = V4, nbrGenes = V5)

## Mapped UMI
mappedumi <- read.delim(file.path(alevinDir, "MappedUmi.txt"),
                        header = FALSE, as.is = TRUE) %>%
    dplyr::rename(CB = V1, nbrMappedUMI = V2)

## Final set of whitelisted CBs
finalwhitelist <- read.delim(file.path(alevinDir, "whitelist.txt"), 
                             header = FALSE, as.is = TRUE)$V1

## Quantification
quantmat <- readAlevin(baseDir)
quants <- data.frame(CB = colnames(quantmat),
                     totalUMICount = colSums(quantmat),
                     nbrGenes2 = colSums(quantmat >= 0.05),
                     stringsAsFactors = FALSE)

## Merge information about quantified CBs
quantbcs <- filtcbfreq %>% 
    dplyr::full_join(featuredump, by = "CB") %>%
    dplyr::full_join(mappedumi, by = "CB") %>%
    dplyr::full_join(quants, by = "CB") %>%
    dplyr::mutate(inFinalWhiteList = CB %in% finalwhitelist)

## Meta information and command information
metainfo <- rjson::fromJSON(file = file.path(baseDir, "aux_info/meta_info.json"))
cmdinfo <- rjson::fromJSON(file = file.path(baseDir, "cmd_info.json"))
```

## Version info

```{r}
knitr::kable(
    t(data.frame(`Start time` = metainfo$start_time,
                 `Salmon version` = metainfo$salmon_version,
                 `Index` = cmdinfo$index,
                 `R1file` = cmdinfo$mates1,
                 `R2file` = cmdinfo$mates2,
                 `tgMap` = cmdinfo$tgMap,
                 stringsAsFactors = FALSE,
                 check.names = FALSE))
)
```

## Summary table

```{r}
if (!quiet) message("Generating summary table...")
knitr::kable(
    t(data.frame(`Total number of processed reads` = as.character(metainfo$num_processed),
                 `Number of reads with valid barcode (no Ns)` = as.character(round(sum(rawcbfreq$originalFreq))),
                 `Nbr whitelisted barcodes (first round)` = as.character(nrow(quantbcs)),
                 `Fraction reads in whitelisted barcodes` = paste0(signif(100 * sum(quantbcs$collapsedFreq)/sum(rawcbfreq$originalFreq), 4), "%"),
                 `Mean reads per cell` = round(mean(quantbcs$collapsedFreq)),
                 `Median reads per cell` = round(stats::median(quantbcs$collapsedFreq)),
                 `Median nbr detected genes` = stats::median(quantbcs$nbrGenes2),
                 `Total nbr detected genes` = sum(rowSums(quantmat) > 0),
                 `Median UMI count` = stats::median(quantbcs$totalUMICount),
                 `Final nbr whitelisted barcodes` = sum(quantbcs$inFinalWhiteList),
                 `Fraction reads in final whitelisted barcodes` = paste0(signif(100 *  sum(quantbcs$collapsedFreq[quantbcs$inFinalWhiteList])/sum(rawcbfreq$originalFreq), 4), "%"),
                 stringsAsFactors = FALSE,
                 check.names = FALSE))
)
```

## Knee plot

The knee plot displays the number of times a cell barcode is observed, and is
used to define an initial set of whitelisted cell barcodes.

```{r}
if (!quiet) message("Generating knee plot...")
ggplot(rawcbfreq %>% dplyr::mutate(origwl = (ranking <= nrow(quantbcs))),
       aes(x = ranking, y = originalFreq)) + 
    geom_line(size = 2, aes(color = origwl)) + 
    scale_x_log10() + scale_y_log10() + 
    xlab("Cell barcode rank") + ylab("Cell barcode frequency") + 
    theme_bw() + 
    theme(legend.position = "none",
          axis.title = element_text(size = 12)) + 
    scale_color_manual(values = c(`TRUE` = "red", `FALSE` = "black")) + 
    geom_label(data = rawcbfreq[nrow(quantbcs), ], 
               aes(label = paste0("(", ranking, ", ", originalFreq, ")")),
               hjust = 0, nudge_x = 0.1)
```

## Correcting barcodes and merging with original whitelist

Once the initial set of whitelisted cell barcodes is defined, Alevin goes
through the remaining cell barcodes. If a cell barcode is similar enough to a
whitelisted barcode, it will be corrected to the whitelisted one. The figure
below shows the original frequency of the whitelisted barcodes vs the frequency
after this correction. The reads corresponding to cell barcodes that can not be
corrected to whitelisted barcode are discarded. After quantification, a
refinement of the cell barcode whitelist is performed, with the aim to exclude
low quality cells. The color in the figure below indicates whether a cell
barcode is included in this final whitelist.

```{r}
if (!quiet) message("Generating barcode collapsing plot...")
ggplot(quantbcs, aes(x = originalFreq, y = collapsedFreq, color = inFinalWhiteList)) + 
    geom_abline(slope = 1, intercept = 0) + 
    geom_point() + theme_bw() + 
    theme(axis.title = element_text(size = 12)) + 
    scale_color_manual(values = c(`TRUE` = "red", `FALSE` = "darkgreen")) + 
    xlab("Cell barcode frequency, original whitelist") + 
    ylab("Cell barcode frequency, following reassignment")
```

## Quantification

The plots below show the association between the cell barcode frequency (the
number of observed reads corresponding to a cell barcode), the total UMI count
(obtained by summing the UMI counts for the individual genes in the returned
count matrix) and the number of detected genes (also obtained from the returned
count matrix). The cell barcodes are colored by whether or not they are included
in the final whitelist.

These figures can give an indication of whether the sequenced reads actually
align to genes, as well as the duplication rate and the degree of saturation.

```{r}
if (!quiet) message("Generating quantification summary plot...")
ggpairs(quantbcs %>% dplyr::rename(`Barcode frequency` = "collapsedFreq",
                                   `Total UMI count` = "totalUMICount",
                                   `Nbr detected genes` = "nbrGenes2"),
        mapping = aes(colour = inFinalWhiteList), 
        columns = c("Barcode frequency", "Total UMI count", 
                    "Nbr detected genes"),
    upper = list(continuous = function(data, mapping, ...) {
         ggally_cor(data = data, mapping = mapping) + 
            scale_colour_manual(values = c("darkgreen", "red"))}),
    lower = list(continuous = function(data, mapping, ...) {
         ggally_points(data = data, mapping = mapping, alpha = 0.5) + 
            scale_colour_manual(values = c("darkgreen", "red"))}),
    diag = list(continuous = function(data, mapping, ...) {
         ggally_densityDiag(data = data, mapping = mapping, alpha = 0.5) + 
            scale_fill_manual(values = c("darkgreen", "red"))})) + 
    theme_bw()
```

## Knee plot, number of detected genes

The plot below shows the number of detected genes as a function of barcode rank,
for the first set of whitelisted barcodes.

```{r}
ggplot(quantbcs %>% dplyr::arrange(desc(nbrGenes2)) %>%
           dplyr::mutate(x = seq_along(nbrGenes2)), 
       aes(x = x, y = nbrGenes2)) + 
    geom_line(size = 2) + 
    #scale_x_log10() + scale_y_log10() + 
    xlab("Cell barcode rank") + ylab("Number of detected genes") + 
    theme_bw() + 
    theme(legend.position = "none",
          axis.title = element_text(size = 12))
```


## Session info

```{r}
sessionInfo()
```

